{"componentChunkName":"component---src-templates-post-template-tsx","path":"/220722_1/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h3>1. 문제 설정 확인</h3>\n<p><a href=\"https://algospot.com/judge/problem/read/PICNIC\" target=\"_blank\" rel=\"nofollow\">종만북 문제 링크 : PICNIC</a></p>\n<p>모든 학생들에게 짝을 하나씩 만들어줘야 한다.</p>\n<h3>2. 문제 풀이</h3>\n<p>저번에 다뤘던 BOGGLE GAME 보다도 더 쉬운 문제다. 하지만 약간 Tricky 한 점이, 바로 중복의 카운트다.\r\n재귀함수를 호출하면서 어떻게 중복을 카운트 하지 않을 것인가?</p>\n<p>예를 들어, 중복을 제거하지 않는다면 (0, 1), (1, 0)을 두 번씩이나 카운트 하게 된다.\r\n여기서 알고리즘을 처음 접하는 분들이라면 으례</p>\n<p><strong>엥 ? 그거 그냥 result 구한 다음 2로 나눠주면 되지 않을까요?</strong></p>\n<p>라는.. 달콤한 유혹에 빠지기 쉽지만, 당연히 그렇게 간단하지 않다. 왜냐하면, 단순히 (0, 1) (1, 0)의 순서쌍을 두 번 세는것이 아닌,\r\n짝을 짓는 <strong>순서</strong> 까지 무시해버린다. 예를 들자면,</p>\n<p>(1, 0) (2, 3) (4, 5)로 짝지은것과\r\n(2, 3) (1, 0) (4, 5)로 짝지은것을 다른 경우로 생각한다는 말이다.</p>\n<p>그렇다면 이런 중복 제거를 어떻게 구현할 수 있을까?</p>\n<p>간단하다. 번호가 빠른 사람들 먼저 짝 지어주면 된다. 오해하면 안 되는게, 번호가 빠른 사람들을 <strong>우선적으로</strong> 짝 지어주는 것이지,\r\n번호가 빠른 사람들만 짝 짓고 (마치 정렬처럼) 떙이 아니다. 백트래킹은 백트래킹대로 해서, 모든 경우의 수를 구하되, 중복되는 경우에는\r\n번호가 가장 빠른 경우의 순서쌍만 카운트하겠다는 뜻이다.</p>\n<p>(1, 0) (2, 3) (4, 5)로 짝지은것과\r\n(2, 3) (1, 0) (4, 5)로 짝지은것것 중, 번호가 더 빠른 첫 번째의 것만 카운트해주면 된다.</p>\n<p>코드도 어렵지 않다.</p>\n<h3>3. 해답 코드</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">#include &lt;iostream>\r\n#include &lt;vector>\r\nusing namespace  std;\r\n\r\nint solution(vector&lt;vector&lt;bool>> student, vector&lt;bool> &amp;isTaken, int length) {\r\n    int firstFree = -1;\r\n    for (int i = 0; i &lt; length; i++){\r\n        if(!isTaken[i]){\r\n            firstFree = i;\r\n            break;\r\n        }\r\n    }\r\n    if (firstFree == -1) {\r\n        return 1;\r\n    }\r\n    int ret = 0;\r\n    for(int pairWith = firstFree + 1; pairWith &lt; length; pairWith++){\r\n        if(!isTaken[pairWith] &amp;&amp; student[firstFree][pairWith]) {\r\n            isTaken[firstFree] = isTaken[pairWith] = true;\r\n            ret += solution(student, isTaken, length);\r\n            isTaken[firstFree] = isTaken[pairWith] = false;\r\n        }\r\n    }\r\n    return ret;\r\n}\r\n\r\nint main () {\r\n    int n;\r\n    cin >> n;\r\n    for(int i=0; i&lt; n; i++){\r\n        int a, b;\r\n        cin >> a >> b;\r\n        vector&lt;vector&lt;bool>> student;\r\n        vector&lt;bool> isTaken(a, false);\r\n        vector&lt;bool> arr(a, false);\r\n        for(int j = 0; j &lt; a; j++){\r\n            student.push_back(arr);\r\n        }\r\n        for(int j = 0; j &lt; b; j++){\r\n            int x, y;\r\n            cin >> x >> y;\r\n            student[x][y] = true;\r\n            student[y][x] = true;\r\n        }\r\n        cout &lt;&lt; solution(student, isTaken, a) &lt;&lt; endl;\r\n    }\r\n}\r\n</code></pre></div>\n<p>이런식으로, 그냥 백트래킹을 구현하되 중복을 제거해주기 위해 남은 사람들 중 가장 빠른 사람의 짝을 찾아준다.</p>\n<p>문제과 별개로…\r\n어제 C++ 배열을 다뤄보고, 꽤나 멘붕이 왔다. (…) 익숙해지면 괜찮겠지만, 아직까지는 솔직히 감이 잘 안 잡힌다.\r\n하지만 vector의 경우엔 다르다. 꽤나 직관적이고, 마치 파이썬의 배열 (물론 파이썬보단 다루긴 훨씬 어렵지만) 다루듯\r\n다룰 수 있어, 일단은 vector를 사용하려고 한다. 다음 포스트로는 vector와 깡 배열의 차이, 또 접근 방법의 차이 등등을\r\n정리해서 올려보려고 한다.</p>\n<hr>\n<h2>Source</h2>\n<ul>\n<li>종만북, 2022.07.22</li>\n<li>CLion</li>\n</ul>","frontmatter":{"title":"종만북 PICNIC C++ 풀이 (코드제공)","summary":"종만북 PICNIC C++ 풀이, 재귀함수의 적용 및 방문처리 중복제거 활용","date":"2022.07.21.","categories":["algorithm","KOR","Cpp"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAABjklEQVQoz42STU9aQRSG+SF2Q1tD4nXmzDlnhguXW70XLxekKQJBIk0JSTXiRxCIC41KbN24xv/QnUmTpjs37rr0F5j+gHbXPYYPFwVt+mSW75M575yJ0Az8PFPJyKwMAEopAJCPAIAQAgCelTUPDyK6ruukkn7aC0bkclnfXw6CwPO8cWZaRqIY4AKgZj4+Om5u7u83u+e9zxcXn3Z2D7ab3X6/32m3BdK8VDglK6JWxq4uGUtiIqmru/ZGy/ihsSxey6v2RxGPG0m6kDLdrD0ccCxrHt65F9iDk+C+6RZX89mCd/Y9evnjZWU7ng+Ld1+jg58vzjuUCYt3W+7gNOjlEzGJmimiiSyF62/M75Z/U3e8Zd8Lk4dfXp18i641jGOvXF+9/nU7t/WeE25wXXP+dPzNdHxUcDQ2EwlFSU3MJEBJKcK3S6VqTqpFa1GyNoV3qwsWSAAkcgwL9XdnpkkNZgZQKcetf2iUy+VKpVKr1UqlMoAc7xmR+B97Hj0+IiHryd9QSj0Ze1r+Tx4ALcmkN73Vo1MAAAAASUVORK5CYII="},"images":{"fallback":{"src":"/static/cbbf1da5aea824ae495a6410873b66eb/1c771/Algorithm.png","srcSet":"/static/cbbf1da5aea824ae495a6410873b66eb/deefd/Algorithm.png 75w,\n/static/cbbf1da5aea824ae495a6410873b66eb/292ee/Algorithm.png 150w,\n/static/cbbf1da5aea824ae495a6410873b66eb/1c771/Algorithm.png 299w","sizes":"(min-width: 299px) 299px, 100vw"},"sources":[{"srcSet":"/static/cbbf1da5aea824ae495a6410873b66eb/0e611/Algorithm.webp 75w,\n/static/cbbf1da5aea824ae495a6410873b66eb/6958a/Algorithm.webp 150w,\n/static/cbbf1da5aea824ae495a6410873b66eb/2a405/Algorithm.webp 299w","type":"image/webp","sizes":"(min-width: 299px) 299px, 100vw"}]},"width":299,"height":168}},"publicURL":"/static/cbbf1da5aea824ae495a6410873b66eb/Algorithm.png"}}}}]}},"pageContext":{"slug":"/220722_1/"}},"staticQueryHashes":[]}