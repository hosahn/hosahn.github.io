{"componentChunkName":"component---src-templates-post-template-tsx","path":"/220910/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h3>1. 문제 설정 확인</h3>\n<p><a href=\"https://www.acmicpc.net/problem/1655\" target=\"_blank\" rel=\"nofollow\">백준 1655번 링크</a></p>\n<h4>1. 우리는 N번만큼 정수를 입력받는다</h4>\n<h4>2. 입력받을 때마다 지금까지 입력받은 수들 중 중간값을 출력한다.</h4>\n<h3>2. 문제 풀이</h3>\n<p>1655에선 특이하게 항상 현재까지 입력 된 수들 중 <strong>중간값</strong>을 출력해야한다.</p>\n<p>물론, 일반적으로 가장 좋은(쉬운) 방법은 for문을 한 번 돌때마다 sort하고(아마 이 경우는 간단한 insertion sort가 좋을 듯 하다.) Length / 2 를 인덱스로 갖는 요소를 출력하면 되지만, 그렇다면 이 문제가 골드 2일 이유가 전혀 없다(…)</p>\n<p>여기서 우리는 heap를 사용해 문제를 해결하여야 한다. 그렇다면 heap를 이용해 중간값을 출력하는 방법은 뭐가 있을까?</p>\n<p>Heap의 종류는 Max Heap과 Min Heap로 나뉜다. 그렇다면 이 둘을 적절히 섞으면 중간값을 빠르게 구할 수 있지 않을까? 아이디어는 다음과 같다 :</p>\n<h4>0. Max Heap과 Min Heap 용 array 2개를 만든다.</h4>\n<h4>1. Max Heap과 Min Heap의 길이가 일치하도록 번갈아가며 숫자를 넣어준다.#### 1-1. 단, Min Heap의 경우에는 Min Heap중 가장 큰 숫자가 위로 오게 하기 위헤 숫자에 minus를 붙혀서 넣는다.</h4>\n<h4>2. 단, Min Heap의 가장 위에 있는 숫자가 Max Heap의 가장 위에 있는 숫자보다 크다면, 두 숫자를 바꿔준다.</h4>\n<h4>2-1. 이렇게 하면 Min Heap에는 항상 Max Heap보다 작은 숫자가 오게되고, Min Heap의 가장 꼭대기에는 Max Heap보다 작은 숫자들 중 가장 큰 수가 오게 된다.</h4>\n<h4>2-2. 1번의 조건에 의해 두 heap의 길이는 같으므로, Min Heap[0]은 중간값이 된다.</h4>\n<h4>3. 과정이 끝나면 Min Heap의 가장 위에 있는 숫자를 출력해준다.</h4>\n<h3>3. 해답 코드</h3>\n<p>Python은 기본적으로 최소 힙만을 제공한다. 따라서 Min Heap의 구현에 있어서는 조금 생각을 하면서 따라와야 한다. 하지만 큰 어려움은 없을것이다. 단지 Max Heap에서 가장 작은 요소보다 작은 요소들을 Min Heap에 넣는데, Min Heap는 최대 힙이라 가장 위에 가장 큰 값이 올라올 뿐이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import sys\r\nimport heapq\r\n\r\ninput = sys.stdin.readline\r\nN = int(input())\r\nmax_heap = []\r\nmin_heap = []\r\n\r\nfor _ in range(N) :\r\n    num = int(input())\r\n    if len(max_heap) == len(min_heap) :\r\n        heapq.heappush(min_heap, -num)\r\n    else :\r\n        heapq.heappush(max_heap, num)\r\n    if min_heap and -min_heap[0] > max_heap[0] :\r\n        A = heapq.heappop(max_heap)\r\n        B = heapq.heappop(min_heap)\r\n        heapq.heappush(min_heap, -A)\r\n        heapq.heappush(max_heap, -B)\r\n    print(-min_heap[0])</code></pre></div>\n<hr>\n<h2>Source</h2>\n<ul>\n<li>Baekjoon, 2022.07.18</li>\n<li>Pycharm</li>\n</ul>","frontmatter":{"title":"백준 Nr 1655 가운데를 말해요 [Python] 풀이","summary":"백준 문제 1655번의 파이썬 풀이(코드제공) Heap, Sort","date":"2022.09.10.","before":"2022.07.30.","after":"2022.09.11.","categories":["algorithm","KOR","python"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAABjklEQVQoz42STU9aQRSG+SF2Q1tD4nXmzDlnhguXW70XLxekKQJBIk0JSTXiRxCIC41KbN24xv/QnUmTpjs37rr0F5j+gHbXPYYPFwVt+mSW75M575yJ0Az8PFPJyKwMAEopAJCPAIAQAgCelTUPDyK6ruukkn7aC0bkclnfXw6CwPO8cWZaRqIY4AKgZj4+Om5u7u83u+e9zxcXn3Z2D7ab3X6/32m3BdK8VDglK6JWxq4uGUtiIqmru/ZGy/ihsSxey6v2RxGPG0m6kDLdrD0ccCxrHt65F9iDk+C+6RZX89mCd/Y9evnjZWU7ng+Ld1+jg58vzjuUCYt3W+7gNOjlEzGJmimiiSyF62/M75Z/U3e8Zd8Lk4dfXp18i641jGOvXF+9/nU7t/WeE25wXXP+dPzNdHxUcDQ2EwlFSU3MJEBJKcK3S6VqTqpFa1GyNoV3qwsWSAAkcgwL9XdnpkkNZgZQKcetf2iUy+VKpVKr1UqlMoAc7xmR+B97Hj0+IiHryd9QSj0Ze1r+Tx4ALcmkN73Vo1MAAAAASUVORK5CYII="},"images":{"fallback":{"src":"/static/cbbf1da5aea824ae495a6410873b66eb/1c771/Algorithm.png","srcSet":"/static/cbbf1da5aea824ae495a6410873b66eb/deefd/Algorithm.png 75w,\n/static/cbbf1da5aea824ae495a6410873b66eb/292ee/Algorithm.png 150w,\n/static/cbbf1da5aea824ae495a6410873b66eb/1c771/Algorithm.png 299w","sizes":"(min-width: 299px) 299px, 100vw"},"sources":[{"srcSet":"/static/cbbf1da5aea824ae495a6410873b66eb/0e611/Algorithm.webp 75w,\n/static/cbbf1da5aea824ae495a6410873b66eb/6958a/Algorithm.webp 150w,\n/static/cbbf1da5aea824ae495a6410873b66eb/2a405/Algorithm.webp 299w","type":"image/webp","sizes":"(min-width: 299px) 299px, 100vw"}]},"width":299,"height":168}},"publicURL":"/static/cbbf1da5aea824ae495a6410873b66eb/Algorithm.png"}}}}]}},"pageContext":{"slug":"/220910/"}},"staticQueryHashes":[]}