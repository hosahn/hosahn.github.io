{"componentChunkName":"component---src-templates-post-template-tsx","path":"/220726/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h3>1. 문제 설정 확인</h3>\n<p><a href=\"https://www.acmicpc.net/problem/2667\" target=\"_blank\" rel=\"nofollow\">종만북 문제 링크 : PICNIC</a></p>\n<h3>2. 문제 풀이</h3>\n<p>저번에 다뤘던 BOGGLE GAME 보다도 더 쉬운 문제다. 하지만 약간 Tricky 한 점이, 바로 중복의 카운트다.\r\n재귀함수를 호출하면서 어떻게 중복을 카운트 하지 않을 것인가?</p>\n<p>예를 들어, 중복을 제거하지 않는다면 (0, 1), (1, 0)을 두 번씩이나 카운트 하게 된다.\r\n여기서 알고리즘을 처음 접하는 분들이라면 으례</p>\n<p><strong>엥 ? 그거 그냥 result 구한 다음 2로 나눠주면 되지 않을까요?</strong></p>\n<p>라는.. 달콤한 유혹에 빠지기 쉽지만, 당연히 그렇게 간단하지 않다. 왜냐하면, 단순히 (0, 1) (1, 0)의 순서쌍을 두 번 세는것이 아닌,\r\n짝을 짓는 <strong>순서</strong> 까지 무시해버린다. 예를 들자면,</p>\n<p>(1, 0) (2, 3) (4, 5)로 짝지은것과\r\n(2, 3) (1, 0) (4, 5)로 짝지은것을 다른 경우로 생각한다는 말이다.</p>\n<p>그렇다면 이런 중복 제거를 어떻게 구현할 수 있을까?</p>\n<p>간단하다. 번호가 빠른 사람들 먼저 짝 지어주면 된다. 오해하면 안 되는게, 번호가 빠른 사람들을 <strong>우선적으로</strong> 짝 지어주는 것이지,\r\n번호가 빠른 사람들만 짝 짓고 (마치 정렬처럼) 떙이 아니다. 백트래킹은 백트래킹대로 해서, 모든 경우의 수를 구하되, 중복되는 경우에는\r\n번호가 가장 빠른 경우의 순서쌍만 카운트하겠다는 뜻이다.</p>\n<p>(1, 0) (2, 3) (4, 5)로 짝지은것과\r\n(2, 3) (1, 0) (4, 5)로 짝지은것것 중, 번호가 더 빠른 첫 번째의 것만 카운트해주면 된다.</p>\n<p>코드도 어렵지 않다.</p>\n<h3>3. 해답 코드</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">#include &lt;iostream>\r\n#include &lt;vector>\r\nusing namespace  std;\r\n\r\nint solution(vector&lt;vector&lt;bool>> student, vector&lt;bool> &amp;isTaken, int length) {\r\n    int firstFree = -1;\r\n    for (int i = 0; i &lt; length; i++){\r\n        if(!isTaken[i]){\r\n            firstFree = i;\r\n            break;\r\n        }\r\n    }\r\n    if (firstFree == -1) {\r\n        return 1;\r\n    }\r\n    int ret = 0;\r\n    for(int pairWith = firstFree + 1; pairWith &lt; length; pairWith++){\r\n        if(!isTaken[pairWith] &amp;&amp; student[firstFree][pairWith]) {\r\n            isTaken[firstFree] = isTaken[pairWith] = true;\r\n            ret += solution(student, isTaken, length);\r\n            isTaken[firstFree] = isTaken[pairWith] = false;\r\n        }\r\n    }\r\n    return ret;\r\n}\r\n\r\nint main () {\r\n    int n;\r\n    cin >> n;\r\n    for(int i=0; i&lt; n; i++){\r\n        int a, b;\r\n        cin >> a >> b;\r\n        vector&lt;vector&lt;bool>> student;\r\n        vector&lt;bool> isTaken(a, false);\r\n        vector&lt;bool> arr(a, false);\r\n        for(int j = 0; j &lt; a; j++){\r\n            student.push_back(arr);\r\n        }\r\n        for(int j = 0; j &lt; b; j++){\r\n            int x, y;\r\n            cin >> x >> y;\r\n            student[x][y] = true;\r\n            student[y][x] = true;\r\n        }\r\n        cout &lt;&lt; solution(student, isTaken, a) &lt;&lt; endl;\r\n    }\r\n}\r\n</code></pre></div>\n<p>이런식으로, 그냥 백트래킹을 구현하되 중복을 제거해주기 위해 남은 사람들 중 가장 빠른 사람의 짝을 찾아준다.</p>\n<p>문제과 별개로…\r\n어제 C++ 배열을 다뤄보고, 꽤나 멘붕이 왔다. (…) 익숙해지면 괜찮겠지만, 아직까지는 솔직히 감이 잘 안 잡힌다.\r\n하지만 vector의 경우엔 다르다. 꽤나 직관적이고, 마치 파이썬의 배열 (물론 파이썬보단 다루긴 훨씬 어렵지만) 다루듯\r\n다룰 수 있어, 일단은 vector를 사용하려고 한다. 다음 포스트로는 vector와 깡 배열의 차이, 또 접근 방법의 차이 등등을\r\n정리해서 올려보려고 한다.</p>\n<hr>\n<h2>Source</h2>\n<ul>\n<li>종만북, 2022.07.22</li>\n<li>CLion</li>\n</ul>","frontmatter":{"title":"해킹을 위한 WEB 기초지식(1) : 웹 기초 (HTTP, Cookie/Session, Encoding)","summary":"","date":"2022.07.26.","categories":["C-SEC","KOR"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wgARCAANABQDASIAAhEBAxEB/8QAGQAAAgMBAAAAAAAAAAAAAAAAAAYBBAcJ/8QAFQEBAQAAAAAAAAAAAAAAAAAABQT/2gAMAwEAAhADEAAAAecqxk1Wh+RFETf/xAAbEAACAwEBAQAAAAAAAAAAAAAEBQECAwYAB//aAAgBAQABBQLk/ozxAp6+x250njzKluVRkeVbT188ot//xAAfEQACAgIBBQAAAAAAAAAAAAACAwEEERMSACFRktL/2gAIAQMBAT8B2ipFjU+yabLh3VyNorN1QQFT5GXGOYTKlxiOWAzy7zES0vA+0/PX/8QAHREAAgIDAAMAAAAAAAAAAAAAAgMBBBITIQAx0f/aAAgBAgEBPwGuMuOvJoppdUSYJeCVbhTaYb2I2CkSIJsG50wXM2nOMz0t7I5krnPR/PP/xAAmEAACAQIGAQQDAAAAAAAAAAABAgMEEgAFERMhMSIUFSNBMpLh/9oACAEBAAY/Aq/KJs3zY0sdJFQ5E0NXLTS5PPNOWhqKYMHtowj1Hqqa2QS7aIgAYuPccyzQZjIslRTpWqoaOojgndd7eXht1bXSxdOT4AnHLc/ficEaq61NHJQkSC/bjHzI8Wv4yo6eL92ySL0xxtONVU3qLmtTstYo0CljoSR9jrHCn9v5j//EABwQAQEAAgIDAAAAAAAAAAAAAAERACFBUTFxgf/aAAgBAQABPyHWJvxKWgfi8l2Skpfpos8FGJji06G0TyMHZz1jUCzgTuk9EUsRNJkdSKwnsSquMiP35+M//9oADAMBAAIAAwAAABCQH//EABgRAQEBAQEAAAAAAAAAAAAAAAERACFx/9oACAEDAQE/EE+TpdStOdiavBQ21X17v//EABkRAAIDAQAAAAAAAAAAAAAAABEhAAFBMf/aAAgBAgEBPxB+k27FYwBSsS4wEHlQrAzBqpT/xAAZEAEBAQEBAQAAAAAAAAAAAAABESEAMUH/2gAIAQEAAT8Qm5D613Vaz4sCNvgJQCOeKY0zpwewxUIRguqIInPHcqiaKJ4IxFQZhRsyiwbhBPoTrDrq6VSjvqK/Xv/Z"},"images":{"fallback":{"src":"/static/19e515bba8750881aa8c0a71dc14e660/8c915/C_Sec.jpg","srcSet":"/static/19e515bba8750881aa8c0a71dc14e660/2e6e0/C_Sec.jpg 270w,\n/static/19e515bba8750881aa8c0a71dc14e660/edde1/C_Sec.jpg 540w,\n/static/19e515bba8750881aa8c0a71dc14e660/8c915/C_Sec.jpg 1080w","sizes":"(min-width: 1080px) 1080px, 100vw"},"sources":[{"srcSet":"/static/19e515bba8750881aa8c0a71dc14e660/2e1cd/C_Sec.webp 270w,\n/static/19e515bba8750881aa8c0a71dc14e660/08f1e/C_Sec.webp 540w,\n/static/19e515bba8750881aa8c0a71dc14e660/c34ed/C_Sec.webp 1080w","type":"image/webp","sizes":"(min-width: 1080px) 1080px, 100vw"}]},"width":1080,"height":720}},"publicURL":"/static/19e515bba8750881aa8c0a71dc14e660/C_Sec.jpg"}}}}]}},"pageContext":{"slug":"/220726/"}},"staticQueryHashes":[]}