{"componentChunkName":"component---src-templates-post-template-tsx","path":"/220721_2/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<p><strong>이 포스트는 C++, C의 “포인터” 개념에 대해 다룹니다.</strong></p>\n<h3>1. 포인터란?</h3>\n<p>C에서의 변수는, 값을 할당받은 메모리의 한 부분이다.\n즉, 우리가 변수를 initialilze 할 때, 사용 가능한 메모리가 변수에 할당되고,\n값이 여기에 저장된다.</p>\n<p>우리가 int n이라는 변수를 사용할 때, cout &#x3C;&#x3C; n이라는 출력 코드를 작성하면\n컴파일러에서 n을 할당된 메모리 주소로 변환해줘 자동으로 값이 참조된다.</p>\n<h3>2. 포인터가 필요한 이유</h3>\n<p><strong>그렇다면 이 포인터라는것은 왜 필요할까?</strong></p>\n<h4>1. call by reference.</h4>\n<p>일반적으로, 알고리즘을 풀 때 main함수 안에서 변수의 값을 이리저리 변경할 때는 굳이 포인터를 쓸 필요가 없다. 최상단 main 함수라면 어차피 그 곳에서\n프로그램이 종료되게 되고, 따로 call by ~~~가 일어날 일이 없기 때문이다. 하지만, 만약 어떠한 변수를 다른 함수의 매개변수로 넘겨준다면?</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">#include &lt;iostream>\nusing namespace std;\n\nvoid abc(int x){\n    x = 2;\n    cout &lt;&lt; x &lt;&lt; endl;\n}\n\nint main(){\n    int x = 1;\n    cout &lt;&lt; x &lt;&lt; endl;\n    abc(x);\n    cout &lt;&lt; x &lt;&lt; endl;\n}\n\n//출력 : 1 2 1</code></pre></div>\n<p>이런 코드가 있다고 할 때, abc함수에 전달되는 값은 진정한 의미의 ‘x’가 아닌\n단순히 x의 할당된 값 (1이라는 상수)이 전달된다. 따라서 abc함수 내부에서 뭔 짓을 하던, x가 저장되어있는 메모리 자체에는 <strong>아무</strong>영향이 없다. 하지만 포인터를 활용할 시에는 호출한 함수에서도 x가 저장되어있는 메모리에 접근이 가능하다.</p>\n<h4>2. 배열의 관리</h4>\n<h4>3. 동적 메모리 할당</h4>\n<p><strong>물론</strong> 이 외에도 다양한 이유가 존재하지만 현재 내 C++ 지식으로 정확히 이해가 가는 이유는 저 세가지다. 나중에 더 공부를 하다보면 추가적인 이유를 찾을 수 있을 것 같다.</p>\n<h3>3. 일반 포인터</h3>\n<p>그렇다면, 이제 기초적인 포인터의 사용부터 알아보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">int *p;\n\nint a = 2;\n\np = &amp;a;</code></pre></div>\n<p>int <em>p라는건 다시 말해서 int형 변수의(int) 주소를(</em>)담을 수 있는 포인터 p의 선언을 뜻한다. 따라서 p에는 어떠한 주소값이 올 수 있으며, 그 주소를 할당받은 변수는 int형이어야 한다.</p>\n<p>또한 p에 변수의 주소를 할당해 줄 때는, &#x26;(변수이름)형식으로 할당한다. 즉 &#x26;a는 a라는 변수의 주소값을 가리킨다.</p>\n<p><strong>&#x26;a의 &#x26;를 “주소 연산자” 라고 한다.</strong></p>\n<p>p는 주소값이다. 그렇다면 p를 이용하여 그 주소값에 실제로 어떤 값이 들어있는지 알 수 있을까?</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">cout &lt;&lt; *p &lt;&lt; endl;\n// 출력 : 2</code></pre></div>\n<p>이 때 사용하는것이 <em>p인데, 아까 p를 선언할 때 쓴 int</em>과는 완전히 다른 놈이다.</p>\n<p>이 친구는 **“역참조 연산자”**라고 하며, 포인터의 실제 값을 가져올때 활용한다.</p>\n<p>즉 : &#x26; = 주소값 전달(함수던, 포인터던 변수던 상관 없다. 메모리에 할당되어있는 존재라면 모두 가지고있다), * = 실제 값 획득(포인터만 사용 가능)로 이해하면 된다.</p>\n<h3>4. 배열 포인터</h3>\n<p>여기까지 이해하고 이제 배열을 확인해보자. 사실 일반 변수를 주고받는것은 그다지 어렵지 않다. 하지만 문제는 배열의 값 참조와 배열의 매개변수 전달이다.\n당연하게도, 알고리즘 문제 풀 때 가장 많이 매개변수로 전달되는것도 배열이다. 그렇다면 배열 포인터는 도대체 무엇일까?</p>\n<p><strong>배열 포인터 : 배열을 가리키는 하나의 포인터</strong></p>\n<p>라고 정의할 수 있는데, 배열은 여러가지 변수의 모음집인데, 어떻게 하나로 모든 변수를 가리킬 수 있을까?</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">int arr[5]={1,2,3,4,5}; </code></pre></div>\n<p>라는 배열을 생각해보자. 일단 배열 포인터의 선언은\n타입 (*포인터이름)[배열크기]이다.</p>\n<p>여기서 보통 알고리즘 문제를 푼다면 저 [배열 크기]가 대부분 정해지지 않았을텐데, 바로 이어서 저런 경우 어떻게 하는지 살펴보겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">int (*ptr)[N] = arr;</code></pre></div>\n<p>일단 선언은 이런 식으로 한다. 이렇게 되면 ptr은 arr 배열의 <strong>첫 번째</strong> 변수를 가리키게 된다.</p>\n<p>여기까지만 하고, 한번 함수에 매개변수로 넘겨보자</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">#include &lt;iostream>\nusing namespace std;\n\nvoid abc(int (*x)[5]){\n    cout &lt;&lt; x &lt;&lt; endl;\n}\n\nint main(){\n\n    int arr[5]={1,2,3,4,5};\n    int (*ptr)[5] = &amp;arr;\n    abc(ptr);\n}\n\n//출력 : arr[0]의 메모리 주소</code></pre></div>\n<p>자, 그렇다면 배열의 순회는 어떻게 할까? 다시 말하지만, main함수의 경우에는 그냥 평범하게 for문으로 순회하면 되지만, 매개변수로 넘어간 abc에서는 배열 요소 변경을 위해서는 call by reference로 호출해야하고, 그게 우리가 그냥 arr이 아닌 arr의 배열 포인터를 매개변수로 넘겨준 이유다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">void abc(int (*x)[5]){\n    for(int i = 0; i &lt; sizeof(*x)/sizeof((*x)[0]); i++){\n        cout &lt;&lt; (*x)[i] &lt;&lt; endl;\n        (*x)[i] = 20;\n    }\n}\n\nint main(){\n\n    int arr[5]={1,2,3,4,5};\n    int (*ptr)[5] = &amp;arr;\n    abc(ptr);\n    for(int i =0; i &lt; 5; i++){\n        cout &lt;&lt; arr[i] &lt;&lt; endl;\n    }\n}</code></pre></div>\n<p>그렇다면 이차원 배열같은경우는 어떻게 넘겨줘야 할까? 전혀 어렵지 않다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">void abc(int (*x)[][5]){\n    for(int i = 0; i &lt; sizeof(*x)[0]/sizeof((*x)[0][0]); i++){\n        cout &lt;&lt; (*x)[0][i] &lt;&lt; endl;\n        (*x)[0][i] = 20;\n    }\n}</code></pre></div>\n<p>이런식으로 넘겨주면 된다. 그렇다면 이제 문제인것이, 보통 알고리즘 풀때는 배열 길이가 미리 정해지는 경우는 극히 드물다. 하지만 우리가 지금까지 배운 방식은 배열 길이를 반드시 알아야지만(즉, 배열 길이가 상수로 주어져야지만) 매개변수로 넘길 수 있는 방법이다. 이를 개선하기 위한 방법이 바로 포인터와 memset을 이용한 배열의 동적 할당이다. 또 다른 방법으로는 순수 C++의 배열 대신 Vector를 사용하는 방법이 있다. 두 가지에 대해 알아보겠다.</p>\n<h3>5. 배열의 동적 할당과 매개변수 전달 (배열 넘기기, Vector 넘기기)</h3>\n<h4>1. 순수 배열의 동적 할당</h4>\n<p>Memset을 이용하여 동적할당하는 방법이 있다.</p>\n<h4>2. Vector 활용 동적 할당</h4>\n<p>Vector는 기본적으로 동적 할당 기능을 제공하는 일종의 C++ 자료구조이다. 사용 방법 또한 매우 간편하며, 내가 C++ 알고리즘을 풀때도 Vector를 많이 이용한다.</p>\n<h3>6. 배열과 vector의 차이</h3>\n<p>그렇다면 두 배열(?)의 차이와 장단점은 무엇일까? 간단히 정리해보았다.</p>\n<h3>7. 알고리즘 문제풀이를 위한 배열과 vector의 활용법 총 정리</h3>\n<p>몇 가지 예시를 들어 실제 알고리즘 문제를 풀 때 어떻게 코드를 작성하면 되는지 알아보자.</p>\n<h3>8. 마무리</h3>\n<p>봐도봐도 헷갈리는게 포인터인 것 같습니다.. 저 역시 C++로 알고리즘을 시작한지 몇 주 되지 않았지만, 아직 익숙해지려면 한참이나 멀었다는 생각밖에 안 드네요…ㅋㅋㅋㅋㅋ\n혹시라도 이 포스트에서 틀린 개념이나, 엄밀히 말하자면 보완할 점이 있다면, 언제든지 댓글로 알려주시면 바로바로 확인해서 수정해보도록 하겠습니다!</p>\n<hr>\n<h2>Source</h2>\n<ul>\n<li>종만북, 2022.07.22</li>\n<li>CLion</li>\n</ul>","frontmatter":{"title":"내가 보려고 작성하는 : C, C++에서의 포인터란?","summary":"포인터의 기본적인 개념과 배열 포인터, 포인터 배열 그리고 일반 배열과 vector, 알고리즘 문제풀이를 위한 배열과 vector의 활용법 총 정리까지 다뤄봅니다.","date":"2022.07.21.","categories":["KOR","Cpp"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wgARCAALABQDASIAAhEBAxEB/8QAGQAAAgMBAAAAAAAAAAAAAAAAAAYEBQcI/8QAFgEBAQEAAAAAAAAAAAAAAAAABQcI/9oADAMBAAIQAxAAAAHQE3l5K0pBJ5UDRf8A/8QAGhAAAgMBAQAAAAAAAAAAAAAAAQQCAwUGAP/aAAgBAQABBQKJpieu2FcmDD7rdvQvuM6JutI9/8QAHxEBAAEDBAMAAAAAAAAAAAAAAQIDESIABBJRITJB/9oACAEDAQE/AZ7+JCtSjRzlLGtzyihxcbIDY9er/W6r5VXt1//EAB8RAQACAQQDAQAAAAAAAAAAAAECAxEAEiEiBTFhcf/aAAgBAgEBPwGvxk2yi9v6BmdGzpMcMe2RU59mOfhrbE4Igfhr/8QAJhAAAgECBAUFAAAAAAAAAAAAAQIDBCEAERIxEyJBUWIFEGFysf/aAAgBAQAGPwLXPKIo0uzOVCXtkxaw8b799sKvossdc7RROatngkpiJVc8WmSnqJ2ZOTJVrTRVWeZloETSzNNUVU0kjbniMLdlVSFVR0VQAMVME87vDBKVihssSD6KApbyILfONBkfRfl1Hrv+D2//xAAbEAEAAwEAAwAAAAAAAAAAAAABESExABBBUf/aAAgBAQABPyHabgMDQ2lGQzWjDp4HInrxAGG4TkIJiZcfgg5lPyQHs7ZmtaVkg0lbrc6wT4//2gAMAwEAAgADAAAAEP8AL//EABcRAQEBAQAAAAAAAAAAAAAAAAEhEQD/2gAIAQMBAT8QTcC2UMCH6oRlo8QUBVRVWqq6q1W9/8QAGREBAQADAQAAAAAAAAAAAAAAAREAITFB/9oACAECAQE/ECZrtgDcKTRRZGgAAQAAADgAQDwM/8QAGRABAQEBAQEAAAAAAAAAAAAAAREhABAx/9oACAEBAAE/EFQ/frUsjFWmV6SHGFwCxBESrnGtIv4ptMIy6Ktl7uAJhKK/MUL2xTBdFKKY3mSQ8//Z"},"images":{"fallback":{"src":"/static/9ddca396d7c33b0b576593ba2102ad34/b313c/Cpp.jpg","srcSet":"/static/9ddca396d7c33b0b576593ba2102ad34/1e49e/Cpp.jpg 74w,\n/static/9ddca396d7c33b0b576593ba2102ad34/5686e/Cpp.jpg 148w,\n/static/9ddca396d7c33b0b576593ba2102ad34/b313c/Cpp.jpg 296w","sizes":"(min-width: 296px) 296px, 100vw"},"sources":[{"srcSet":"/static/9ddca396d7c33b0b576593ba2102ad34/e5279/Cpp.webp 74w,\n/static/9ddca396d7c33b0b576593ba2102ad34/b6fe8/Cpp.webp 148w,\n/static/9ddca396d7c33b0b576593ba2102ad34/c102b/Cpp.webp 296w","type":"image/webp","sizes":"(min-width: 296px) 296px, 100vw"}]},"width":296,"height":170}},"publicURL":"/static/9ddca396d7c33b0b576593ba2102ad34/Cpp.jpg"}}}}]}},"pageContext":{"slug":"/220721_2/"}},"staticQueryHashes":[]}