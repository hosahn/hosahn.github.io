{"componentChunkName":"component---src-templates-post-template-tsx","path":"/220914/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h3>1. 문제 설정 확인</h3>\n<p><a href=\"https://algospot.com/judge/problem/read/TRIPATHCNT\" target=\"_blank\" rel=\"nofollow\">종만북 문제 링크 : TRIPATHCNT</a></p>\n<p>저번에 했던 삼각형의 최대 경로에서 한발자국 더 나아가 그 최대 경로의 개수가 얼마인지 카운트 해야한다.</p>\n<p>설명 작성 예정</p>\n<h3>3. 해답 코드</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">#include &lt;iostream>\r\n#include &lt;string.h>\r\nusing namespace std;\r\n\r\nint n;\r\nint size;\r\nint cache[100][100];\r\nint triangle[100][100];\r\nint cache2[100][100];\r\n\r\nint path(int y, int x){\r\n    if (y == size - 1)\r\n        return triangle[y][x];\r\n    int&amp; ret = cache2[y][x];\r\n    if (ret != -1)\r\n        return ret;\r\n    return ret = max(path(y + 1, x), path(y + 1, x + 1)) + triangle[y][x]; // 부분 경로의 최대치를 구한다.\r\n}\r\n\r\nint countPath(int y, int x){\r\n    if (y == size-1) return 1;\r\n    int&amp; ret = cache[y][x];\r\n    if(ret != -1) return ret;\r\n    ret = 0;\r\n    if(path(y+1, x+1) >= path(y+1, x)) ret += countPath(y+1, x+1);\r\n    if(path(y+1, x+1) &lt;= path(y+1, x)) ret += countPath(y+1, x);\r\n    return ret;\r\n}\r\n\r\nint main(){\r\n    ios_base :: sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n    cout.tie(NULL);\r\n    cin >> n;\r\n    for(int i = 0; i &lt; n; i++){\r\n        memset(cache, -1, sizeof(cache));\r\n        memset(cache2, -1, sizeof(cache2));\r\n        memset(triangle, 0, sizeof(triangle));\r\n        cin >> size;\r\n        for(int j = 0; j &lt; size; j++){\r\n            for(int k = 0; k &lt;= j; k++){\r\n                cin >> triangle[j][k];\r\n            }\r\n        }\r\n        int result = countPath(0, 0);\r\n        cout &lt;&lt; result &lt;&lt; endl;\r\n    }\r\n}</code></pre></div>\n<p>슬슬 DP문제에서의 재귀 호출이 뭐가 뭔지 잘 모르겠는 분들이 많을 것 같아요. 제 팁은, 재귀 호출과정에서 도대체 뭐가 일어나는지를\r\n너무 생각하지 않는 게 좋단겁니다. 재귀 호출은 그 다음 호출, 또 그 다음 호출을 거쳐 기저조건에 도달했을 때 값을 return받습니다.\r\n당연히 저희가 그 다음 언젠가의 재귀호출 과정에서 답을 return받을 걸 가정하고 쓰는 기법이니까, 정확한 기저 조건의 설계만 있다면 마법처럼\r\n동작하기 마련이기에, 어떻게 값을 return해 줄건지, 기저 조건은 어떻게 설계할건지가 가장 중요합니다!</p>\n<hr>\n<h2>Source</h2>\n<ul>\n<li>종만북, 2022.07.22</li>\n<li>CLion</li>\n</ul>","frontmatter":{"title":"종만북 삼각형 최대 경로 카운트 (TriPathCnt) C++ 풀이 (코드제공)","summary":"종만북 Tripathcnt C++ 풀이해봅니다!","date":"2022.09.14.","before":"2022.09.13.","after":"2022.09.15.","categories":["Algorithm","KOR","Cpp"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAABhklEQVR42mMwxgFMsAE0NQyY2gzBwMDAQB8M9PT0IGwgiVOzqQkIGRkZ2YCAtZOTg6uri6urq6enB4Tt6ORkamJiilWzhoGRliFQr1FpaVlWWn5WWkF9bWNLS1N2bmFKWsHEiZNKS0sMTUxV9QyN0DQbGBlnuZrHOJjrGBiZW5iGZVhE5pu5eJvr6Jj4uBsVp+pZWZoZGJt6W5uWeFhYmBpDDGAAOlXLwCje0fx/pevzbLtwb09Xb9eq9cpdp5Qj8k08XIKOrlD5/0S2q8LA0S3oWLLd/1q3Tn8rdX0joEYGYAjqGhr72pg+zXE8lmjj5uho72RbuFC1ZptSaIaJpZnb4m71D0dlchONzGxcF4dbfy9yynOzANoH0gyKFWNjPUNjS1NQgOkaGAID2MXTNiTS28BIV1dX39DINMDfW0fXEBjcQNfamJkAFaP4GajfCBa9wHiysrSKj40PDg4JDQuNjIwICQkFxhMkno2MjE3wxDNIBUiNkYkpNG0AjUMkHvyJhHgAACB5pDYwJ+QuAAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/cbbf1da5aea824ae495a6410873b66eb/1c771/Algorithm.png","srcSet":"/static/cbbf1da5aea824ae495a6410873b66eb/deefd/Algorithm.png 75w,\n/static/cbbf1da5aea824ae495a6410873b66eb/292ee/Algorithm.png 150w,\n/static/cbbf1da5aea824ae495a6410873b66eb/1c771/Algorithm.png 299w","sizes":"(min-width: 299px) 299px, 100vw"},"sources":[{"srcSet":"/static/cbbf1da5aea824ae495a6410873b66eb/0e611/Algorithm.webp 75w,\n/static/cbbf1da5aea824ae495a6410873b66eb/6958a/Algorithm.webp 150w,\n/static/cbbf1da5aea824ae495a6410873b66eb/2a405/Algorithm.webp 299w","type":"image/webp","sizes":"(min-width: 299px) 299px, 100vw"}]},"width":299,"height":168}},"publicURL":"/static/cbbf1da5aea824ae495a6410873b66eb/Algorithm.png"}}}}]}},"pageContext":{"slug":"/220914/"}},"staticQueryHashes":["1523927062"],"slicesMap":{}}