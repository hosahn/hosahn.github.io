{"componentChunkName":"component---src-templates-post-template-tsx","path":"/220722/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h3>1. 문제 설정 확인</h3>\n<p><a href=\"https://algospot.com/judge/problem/read/GAMEBOARD\" target=\"_blank\" rel=\"nofollow\">종만북 문제 링크 : GAMEBOARD</a></p>\n<p>딱히 설명할 정도로 문제설정이 복잡하진 않다. 단순히 배열의 모든 요소를 1로 만들 수 있으면 된다.</p>\n<h3>2. 문제 풀이</h3>\n<p>PICNIC과 비슷해보이는 문제다. 일단은 코드부터 보자.</p>\n<h3>3. 해답 코드</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">#include &lt;iostream>\r\n#include &lt;vector>\r\nusing namespace  std;\r\n\r\nconst int coverType[4][3][2] = {\r\n        {{0,0}, {1,0}, {0, 1}},\r\n        {{0, 0}, {0, 1}, {1,1}},\r\n        {{0,0}, {1,0}, {1, 1}},\r\n        {{0,0}, {1,0}, {1,-1}}\r\n};\r\n\r\nbool set(vector&lt;vector&lt;int>> &amp;board, int x, int y, int i, int j){\r\n    bool ok = true;\r\n    for(int k = 0; k &lt; 3; ++k){\r\n        const int nx = x + coverType[i][k][0];\r\n        const int ny = y + coverType[i][k][1];\r\n        if(nx &lt; 0 || nx >= board.size() || ny &lt; 0 || ny >= board[0].size())\r\n            ok = false;\r\n        else {\r\n            board[nx][ny] += j;\r\n            if(board[nx][ny] > 1) ok = false;\r\n        }\r\n    }\r\n    return ok;\r\n}\r\n\r\nint solution(vector&lt;vector&lt;int>> &amp;board, int width, int height){\r\n    int minX = -1;\r\n    int minY;\r\n    for(int i =0; i &lt; height; i++){\r\n        for (int j =0; j&lt; width; j++){\r\n            if (board[i][j] == 0){\r\n                minX = i;\r\n                minY = j;\r\n                break;\r\n            }\r\n        }\r\n        if(minX != -1) break;\r\n    }\r\n    if (minX == -1) return 1;\r\n    int result = 0;\r\n    for (int z =0; z &lt; 4; z++) {\r\n        if(set(board, minX, minY, z, 1)){\r\n            result += solution(board, width, height);\r\n        }\r\n        set(board, minX, minY, z, -1);\r\n    }\r\n    return result;\r\n}\r\n\r\nint main() {\r\n    int n;\r\n    cin >> n;\r\n    char a = '#';\r\n    for(int i = 0; i &lt; n; i++){\r\n        int height, width;\r\n        cin >> height >> width;\r\n        vector&lt;vector&lt;int>> board;\r\n        for(int k = 0; k &lt; height; k++) {\r\n            string str;\r\n            vector&lt;int> line(0);\r\n            cin >> str;\r\n            for (int j = 0; j &lt; width; j++) {\r\n                if (str[j] == a) line.push_back(1);\r\n                else line.push_back(0);\r\n            }\r\n            board.push_back(line);\r\n        }\r\n        cout &lt;&lt; solution(board, width, height) &lt;&lt; endl;\r\n    }\r\n}</code></pre></div>\n<p><strong>코드 설명</strong></p>\n<p>보시다시피, 기본적으로는 백트래킹의 형식을 취한다. 사실 크게 어려운 건 없었다. 기본적인 백트래킹의 형식인</p>\n<ol>\n<li>조건에 따라 방문처리를 하고</li>\n<li>방문처리를 하게될 시 재귀함수를 사용해 안으로 들어가며</li>\n<li>모든 재귀함수의 호출이 끝나고 최상단으로 돌아올 시 방문처리를 해제한다.</li>\n</ol>\n<p>를 취한다. 다만, 무작정 저렇게 구현했다간, 저번 포스트인 PICNIC처럼, 블럭 놓는 순서를 다 구분하게 되다보니,\r\n가장 왼쪽 위부터 블럭을 놓는 것이 필요하고, 그것이 minX minY의 사용 이유이다.</p>\n<p>또 tricky한 점이, 바로 set함수이다. set 함수는</p>\n<ol>\n<li>방문처리가 가능한지의 여부를 반환해준다.</li>\n<li>실제로 함수 내에서 방문처리를 해준다.</li>\n</ol>\n<p>즉, 방문처리를 하되, 이미 방문한 적이 있는 칸이거나 방문을 할 수 없는 칸이라면 false를 리턴해 재귀호출을 막고 바로 방문해제 함수로\r\n들어가게 해주는 함수다. 매개변수 j에 1이나 -1이 오는데, 왜 단순히 board[mx][my] = 1, board[mx][my] = 0을 쓰는것이 아닌 +=를 쓰는지 한 번 생각해보자. 1 0 0 이라는 세 칸을 방문한다면, 모두 1로 동일하게 방문처리를 하면\r\n1 1 1이 된다. 물론 1 0 0에서 이미 1이 있었으니, ok는 false가 될 것이고, 원 함수의 if문을 빠져나가 방문해제 처리를 할 것이다.\r\n그럼 당연하게도, 원래 있던 1 0 0의 1까지 <strong>모두 방문해제 처리되어 0 0 0 이 되어버린다, 즉, 무한루프에 빠진다.</strong>\r\n따라서 += 1 을 해주어 2 1 1을 만들어주고, 나중에 += -1 을 해주어 1 0 0을 만들어주면 된다.</p>\n<p><strong>기억하자, 백트래킹에서 방문처리했던 모든 칸은, 그 방문한 횟수만큼 다시 방문해 방문해제를 거칠 수 밖에 없다</strong></p>\n<p>왜냐하면, 결국 백트래킹의 모든 호출이 끝난 후의 board는 결국 초기 상태 그대로이기 때문이다.</p>\n<p>솔직히 set 함수만 아니면 30분정도 걸렸을 문제인데, set함수에서 계속 오류가 나서 결국 이 한 문제 푸는데 한시간이 넘게 걸려버렸다 (…)\r\n결국 책의 도움을 받아보니, 부호 하나 잘못써서 계속 오류 나던 것이어서, 더욱 현타가 온다… ㅎㅎ…</p>\n<hr>\n<h2>Source</h2>\n<ul>\n<li>종만북, 2022.07.22</li>\n<li>CLion</li>\n</ul>","frontmatter":{"title":"종만북 GAMEBOARD C++ 풀이 (코드제공)","summary":"종만북 GAMEBOARD C++ 풀이, 재귀함수의 적용 및 방문처리 중복제거, 방문해제 함수 (set) 활용","date":"2022.07.22.","before":"2022.07.21.","after":"2022.07.23.","categories":["Algorithm","KOR","Cpp"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAABhklEQVR42mMwxgFMsAE0NQyY2gzBwMDAQB8M9PT0IGwgiVOzqQkIGRkZ2YCAtZOTg6uri6urq6enB4Tt6ORkamJiilWzhoGRliFQr1FpaVlWWn5WWkF9bWNLS1N2bmFKWsHEiZNKS0sMTUxV9QyN0DQbGBlnuZrHOJjrGBiZW5iGZVhE5pu5eJvr6Jj4uBsVp+pZWZoZGJt6W5uWeFhYmBpDDGAAOlXLwCje0fx/pevzbLtwb09Xb9eq9cpdp5Qj8k08XIKOrlD5/0S2q8LA0S3oWLLd/1q3Tn8rdX0joEYGYAjqGhr72pg+zXE8lmjj5uho72RbuFC1ZptSaIaJpZnb4m71D0dlchONzGxcF4dbfy9yynOzANoH0gyKFWNjPUNjS1NQgOkaGAID2MXTNiTS28BIV1dX39DINMDfW0fXEBjcQNfamJkAFaP4GajfCBa9wHiysrSKj40PDg4JDQuNjIwICQkFxhMkno2MjE3wxDNIBUiNkYkpNG0AjUMkHvyJhHgAACB5pDYwJ+QuAAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/cbbf1da5aea824ae495a6410873b66eb/1c771/Algorithm.png","srcSet":"/static/cbbf1da5aea824ae495a6410873b66eb/deefd/Algorithm.png 75w,\n/static/cbbf1da5aea824ae495a6410873b66eb/292ee/Algorithm.png 150w,\n/static/cbbf1da5aea824ae495a6410873b66eb/1c771/Algorithm.png 299w","sizes":"(min-width: 299px) 299px, 100vw"},"sources":[{"srcSet":"/static/cbbf1da5aea824ae495a6410873b66eb/0e611/Algorithm.webp 75w,\n/static/cbbf1da5aea824ae495a6410873b66eb/6958a/Algorithm.webp 150w,\n/static/cbbf1da5aea824ae495a6410873b66eb/2a405/Algorithm.webp 299w","type":"image/webp","sizes":"(min-width: 299px) 299px, 100vw"}]},"width":299,"height":168}},"publicURL":"/static/cbbf1da5aea824ae495a6410873b66eb/Algorithm.png"}}}}]}},"pageContext":{"slug":"/220722/"}},"staticQueryHashes":[],"slicesMap":{}}