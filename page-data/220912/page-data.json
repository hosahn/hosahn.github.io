{"componentChunkName":"component---src-templates-post-template-tsx","path":"/220912/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h3>1. 문제 설정 확인</h3>\n<p><a href=\"https://algospot.com/judge/problem/read/WILDCARD\" target=\"_blank\" rel=\"nofollow\">종만북 문제 링크 : WildCard</a></p>\n<p>이 문제에선 와일드카드가 문자열 안에 포함되어있는 (예 : “app*e”) 문자열이 다른 문자 (예 : “apple”)과 같다고 정의될 수 있는지 판단하는 문제다.</p>\n<p>솔직히 DP에서의 문자열 비교는 조금 꺼려진다. 속도 제한도 빡빡해질 뿐더러, 그냥 (…) 문자열이 싫다. 그런 면에서 WildCard는 어려운 문제라고 판단된다. 이 문제에서의 와일드 카드란 총 2개로 :</p>\n<h4>1. ? : 딱 하나의 문자 (char)만 치환해주는 녀석</h4>\n<h4>2. * : length 1 이상의 문자 혹은 문자열을 치환해주는 녀석</h4>\n<p>이렇게 두 개의 와일드카드가 존재한다. 먼저 어떠한 경우에 true가 return 되는지 보자.</p>\n<h4>0. 공통 조건 : 비교하는 문자열의 끝에 도달하여야 한다.</h4>\n<h4>1. 제일 마지막에 온게 ? 이거나 같은 문자 (예 : “apple”이거나 “appl?“) 인 경우.</h4>\n<h4>2. 제일 마지막에 온 게 * 문자거나, * 문자의 연장인 경우 (예 : “ap*” 이거나 “appl*“)인 경우.</h4>\n<p>1번에 대해서는 누구도 불만이 없을 것이다. 다만 조금 까다로운게 2번 조건이다. *는 문자를 하나만 치환할수도, 1 &#x3C; n 의 어떤 길이도 치환할 수 있기 때문이다. 일단 다른 조건부터 해결해보자.</p>\n<ul>\n<li>\n<ol>\n<li>int&#x26;ret으로 cache[x][y]를 호출한다.</li>\n</ol>\n</li>\n<li>\n<ol start=\"2\">\n<li>만약 방문한 적 있다면 (실패한 경우에는 0, 성공한 경우에는 1)을 즉시 리턴해준다.</li>\n</ol>\n</li>\n<li>\n<ol start=\"3\">\n<li>아직 대상 문자와 비교 문자중 하나라도 끝에 도달하지 않은 경우가 있다면, 또 그 둘의 다음 문자가 일치한다면(혹은 와일드카드 ?라면)다음 문자 비교를 위해 재귀호출한다.</li>\n</ol>\n</li>\n<li>\n<ol start=\"4\">\n<li>만약 대상 문자의 끝에 왔다면, 비교 문자도 끝에 왔는지 확인하고 1을 return한다.</li>\n</ol>\n</li>\n<li>\n<ol start=\"5\">\n<li>만약 현재 대상 문자가 와일드카드 *라면, 와일드카드 *를 유지하고 비교 문자의 다음 문자를 검사하는 경우와 와일드카드를 넘어 두 문자 다 다음 문자를 비교하는 경우, 두 번의 재귀호출을 OR로 묶어 결과값을 반환한다.</li>\n</ol>\n</li>\n<li>\n<ol start=\"6\">\n<li>만약 2~5중 아무것도 아니라면, 이는 와일드카드도 아니고 두 문자가 일치하는 경우도 아닌 실패의 경우이므로 ret = 0값을 return하도록 한다.</li>\n</ol>\n</li>\n</ul>\n<h3>3. 해답 코드</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">#include &lt;iostream>\r\n#include &lt;string.h>\r\n#include &lt;vector>\r\n#include &lt;algorithm>\r\n\r\nusing namespace std;\r\n\r\nint cache[101][101];\r\n\r\nint solution(string target, string tmp, int a, int b, int tmpSize, int targetSize){\r\n    int&amp; ret = cache[a][b];\r\n    if(ret != -1) return ret;\r\n    //방문한 적이 있다면 바로 return\r\n    while(a &lt; targetSize &amp;&amp; b &lt; tmpSize &amp;&amp; (target[a] == '?' || target[a] == tmp[b])) {\r\n        ret = solution(target, tmp, a + 1, b + 1, tmpSize, targetSize);\r\n        return ret;\r\n    }\r\n    // ? 와일드카드인경우\r\n    if(a == targetSize){\r\n        ret = (b == tmpSize);\r\n        return ret;\r\n    }\r\n    // a끝에 도달한경우\r\n    if(target[a] == '*'){\r\n        if((b &lt; tmpSize &amp;&amp; solution(target, tmp, a, b+1, tmpSize, targetSize)) || (a &lt; targetSize &amp;&amp; (solution(target, tmp, a+1, b, tmpSize, targetSize)))){\r\n            //b+1 = a는 계속 *로 머물고 b의 다음칸 대응 검사, a+1 = 이제 * 스킵하고 a의 다음 문자열 검사(사이즈 체크 필요)\r\n            ret = 1;\r\n            return ret;\r\n        }\r\n    }\r\n    ret = 0;\r\n    return ret;\r\n}\r\n\r\nint main(){\r\n    ios_base :: sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n    cout.tie(NULL);\r\n    int n;\r\n    cin >> n;\r\n    for(int i = 0; i &lt; n; i++){\r\n        string target;\r\n        cin >> target;\r\n        int k;\r\n        cin >> k;\r\n        vector&lt;string> ans;\r\n        for(int j = 0; j &lt; k; j++){\r\n            memset(cache, -1, sizeof(cache));\r\n            string tmp;\r\n            cin >> tmp;\r\n            if(solution(target, tmp, 0, 0, tmp.size(), target.size()) == 1){\r\n                ans.push_back(tmp);\r\n            }\r\n        }\r\n        sort(ans.begin(), ans.end());\r\n        for (auto e : ans) {\r\n            cout &lt;&lt; e &lt;&lt; \"\\n\";\r\n        }\r\n    }\r\n}\r\n</code></pre></div>\n<p>P.S. 8장에선 이 문제와 후에 나오는 Quantization 문제가 가장 어려웠다..</p>\n<hr>\n<h2>Source</h2>\n<ul>\n<li>종만북, 2022.07.22</li>\n<li>CLion</li>\n</ul>","frontmatter":{"title":"종만북 와일드 카드(WildCard) C++ 풀이 (코드제공)","summary":"종만북 WILDCARD C++ 풀이해봅니다!","date":"2022.09.12.","before":"2022.09.11.","after":"2022.09.13.","categories":["Algorithm","KOR","Cpp"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAABhklEQVR42mMwxgFMsAE0NQyY2gzBwMDAQB8M9PT0IGwgiVOzqQkIGRkZ2YCAtZOTg6uri6urq6enB4Tt6ORkamJiilWzhoGRliFQr1FpaVlWWn5WWkF9bWNLS1N2bmFKWsHEiZNKS0sMTUxV9QyN0DQbGBlnuZrHOJjrGBiZW5iGZVhE5pu5eJvr6Jj4uBsVp+pZWZoZGJt6W5uWeFhYmBpDDGAAOlXLwCje0fx/pevzbLtwb09Xb9eq9cpdp5Qj8k08XIKOrlD5/0S2q8LA0S3oWLLd/1q3Tn8rdX0joEYGYAjqGhr72pg+zXE8lmjj5uho72RbuFC1ZptSaIaJpZnb4m71D0dlchONzGxcF4dbfy9yynOzANoH0gyKFWNjPUNjS1NQgOkaGAID2MXTNiTS28BIV1dX39DINMDfW0fXEBjcQNfamJkAFaP4GajfCBa9wHiysrSKj40PDg4JDQuNjIwICQkFxhMkno2MjE3wxDNIBUiNkYkpNG0AjUMkHvyJhHgAACB5pDYwJ+QuAAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/cbbf1da5aea824ae495a6410873b66eb/1c771/Algorithm.png","srcSet":"/static/cbbf1da5aea824ae495a6410873b66eb/deefd/Algorithm.png 75w,\n/static/cbbf1da5aea824ae495a6410873b66eb/292ee/Algorithm.png 150w,\n/static/cbbf1da5aea824ae495a6410873b66eb/1c771/Algorithm.png 299w","sizes":"(min-width: 299px) 299px, 100vw"},"sources":[{"srcSet":"/static/cbbf1da5aea824ae495a6410873b66eb/0e611/Algorithm.webp 75w,\n/static/cbbf1da5aea824ae495a6410873b66eb/6958a/Algorithm.webp 150w,\n/static/cbbf1da5aea824ae495a6410873b66eb/2a405/Algorithm.webp 299w","type":"image/webp","sizes":"(min-width: 299px) 299px, 100vw"}]},"width":299,"height":168}},"publicURL":"/static/cbbf1da5aea824ae495a6410873b66eb/Algorithm.png"}}}}]}},"pageContext":{"slug":"/220912/"}},"staticQueryHashes":[],"slicesMap":{}}